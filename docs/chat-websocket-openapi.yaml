openapi: 3.0.3

info:
  title: Trilex Chat WebSocket API
  version: 2.4.0
  description: |
    WebSocket documentation for Trilex Chat System.
    
    ============================================================
    OVERVIEW
    ============================================================
    
    • Single persistent authenticated WebSocket connection
    • JWT token must be passed as query parameter
    • All chat communication happens over this socket
    • Every server event contains a `type` field
    
    Connection format:
    
    Local:
    ws://127.0.0.1:8000/ws/socket/?token=<ACCESS_TOKEN>
    
    Production:
    wss://trilex-1.onrender.com/ws/socket/?token=<ACCESS_TOKEN>
    
    
    ============================================================
    SOCKET CONNECTION FLOW (Frontend Implementation Guide)
    ============================================================
    
    STEP 1 — CONNECT
    ----------------
    Frontend opens WebSocket connection.
    User is automatically added to personal group:
        user_<user_id>
    
    No room is joined automatically.

    Immediately after connection server sends:

    Event: unread_count
    Schema: UnreadCountResponse
    
    Used to initialize notification badge.
    
    ------------------------------------------------------------
    
    STEP 2 — JOIN ROOM
    ------------------
    Frontend sends:
    
    {
      "action": "join_room",
      "room_id": "<ROOM_ID>"
    }
    
    Server responds:
    
    Event: room_joined
    Schema: RoomJoinedResponse
    
    If there is a latest pending message from another user,
    server also triggers:
    
    Event: message_delivered
    Schema: MessageDeliveredResponse
    (Sent ONLY to original sender)
    
    ------------------------------------------------------------
    
    STEP 3 — SEND MESSAGE
    ---------------------
    
    Frontend sends:
    
    {
      "action": "send_message",
      "room_id": "<ROOM_ID>",
      "message": "Hello",
      "client_temp_id": "<UUID>"
    }
    
    Server emits events in this order:
    
    1) message_sent  
       → Sent ONLY to sender  
       → Schema: MessageSentResponse  
       → Purpose: ACK that DB saved message  
    
    2) chat_message  
       → Sent to ALL participants in room  
       → Schema: ChatMessageResponse  
       → Purpose: Real message delivery  
    
    3) room_updated  
       → Sent to ALL participants (user-level group)  
       → Schema: RoomUpdatedResponse  
       → Purpose: Sidebar update (preview + reorder room)
    
    ------------------------------------------------------------
    
    STEP 4 — RECEIVE MESSAGE
    ------------------------
    
    Frontend must listen for:
    
    Event: chat_message  
    Schema: ChatMessageResponse  
    
    This is the main event for receiving new messages.
    
    ------------------------------------------------------------
    
    STEP 5 — DELIVERY LOGIC
    -----------------------
    
    Delivery is NOT triggered per message manually.
    
    Delivery is automatically triggered when:
        A participant joins the room.
    
    Only the LATEST pending message is marked delivered.
    
    Event sent:
    message_delivered
    Schema: MessageDeliveredResponse
    Sent ONLY to original sender.
    
    Frontend should:
    • Mark latest message as delivered
    • Optionally mark older messages visually delivered
    
    This prevents WebSocket flooding.
    
    ------------------------------------------------------------
    
    STEP 6 — MARK READ
    ------------------
    
    Frontend sends:
    
    {
      "action": "mark_read",
      "room_id": "<ROOM_ID>"
    }
    
    Server sends to OTHER participants:
    
    Event: message_read
    Schema: MessageReadResponse
    
    Purpose:
    Indicates that a participant has read messages in this room.

    ============================================================
    NOTIFICATION SYSTEM (REAL-TIME)
    ============================================================

    OVERVIEW
    --------
    • Notifications are user-level events (not room-based)
    • Sent via personal group: user_<user_id>
    • Persisted in database
    • Delivered in real-time via WebSocket
    • Unread counter is pushed automatically

    Notifications are triggered by:
    • Booking events (created, accepted, rejected)
    • Firm invitation events (received, accepted, rejected)

    ------------------------------------------------------------

    WHEN NEW NOTIFICATION IS CREATED
    ---------------------------------
    Server sends TWO events in order:

    1) notification
       → Schema: NotificationResponse
       → Contains full notification payload

    2) unread_count
       → Schema: UnreadCountResponse
       → Updated unread count

    ------------------------------------------------------------

    MARK AS READ (REST API)
    -----------------------
    When notification is marked read via REST:

    POST /notifications/<id>/read/
    OR
    POST /notifications/mark-all-read/

    Server automatically pushes:

    Event: unread_count
    Schema: UnreadCountResponse

    ------------------------------------------------------------

    NOTIFICATION EVENT TYPES
    ------------------------

    booking_created
    booking_accepted
    booking_rejected

    firm_invitation_received
    firm_invitation_accepted
    firm_invitation_rejected

    ============================================================
    EVENT LISTENER REFERENCE (Frontend Must Handle These)
    ============================================================
    
    room_joined       → RoomJoinedResponse  
    room_left         → RoomLeftResponse  
    message_sent      → MessageSentResponse  
    chat_message      → ChatMessageResponse  
    room_updated      → RoomUpdatedResponse  
    message_delivered → MessageDeliveredResponse  
    message_read      → MessageReadResponse  
    notification      → NotificationResponse  
    unread_count      → UnreadCountResponse  
    
    ============================================================
    WEBSOCKET ACTIONS (What Frontend Can Send)
    ============================================================
    
    Action: join_room
    Request Schema: JoinRoomRequest
    
    Action: leave_room
    Request Schema: LeaveRoomRequest
    
    Action: send_message
    Request Schema: SendMessageRequest
    
    Action: mark_read
    Request Schema: MarkReadRequest
    
    ============================================================
    UNIFIED MESSAGE FORMAT
    ============================================================
    
    sender: {
      "id": string,
      "name": string,
      "email": string
    }

    ============================================================
    IMPORTANT DESIGN NOTES
    ============================================================
    
    • chat_message is the event to RECEIVE messages
    • send_message is the action to SEND messages
    • message_sent is only an ACK for sender
    • message_delivered triggers on room join
    • message_read triggers after mark_read
    • room_updated is ONLY for sidebar updates
    • notification is a user-level event
    • unread_count updates notification badge
    • API endpoints are used for pagination and history
    • WebSocket is used for real-time updates only


servers:
  - url: ws://127.0.0.1:8000
    description: Local Development

  - url: wss://trilex-1.onrender.com
    description: Production

paths:
  /ws/socket/:
    get:
      summary: Connect to WebSocket
      description: |
        Establish authenticated WebSocket connection.

        ```javascript
        const socket = new WebSocket(
          "wss://trilex-1.onrender.com/ws/socket/?token=ACCESS_TOKEN"
        );

        socket.onmessage = (event) => {
          const data = JSON.parse(event.data);

          switch(data.type) {

            case "room_joined":
              break;

            case "message_sent":
              break;

            case "chat_message":
              break;

            case "room_updated":
              break;

            case "message_delivered":
              break;

            case "message_read":
              break;

            case "notification":
              // Add to notification list
              break;

            case "unread_count":
              // Update badge counter
              break;
          }
        };
        ```

      parameters:
        - in: query
          name: token
          required: true
          schema:
            type: string
          description: JWT Access Token

      responses:
        "101":
          description: WebSocket Connected

components:
  schemas:

    SenderObject:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        email:
          type: string

    NotificationActorObject:
      type: object
      properties:
        id:
          type: string
        email:
          type: string
        name:
          type: string
        role:
          type: string

    NotificationResponse:
      type: object
      properties:
        type:
          type: string
          example: notification
        notification:
          type: object
          properties:
            id:
              type: string
            type:
              type: string
            title:
              type: string
            message:
              type: string
            entity_type:
              type: string
            entity_id:
              type: string
            metadata:
              type: object
            is_read:
              type: boolean
            created_at:
              type: string
              format: date-time
            actor:
              $ref: '#/components/schemas/NotificationActorObject'

    UnreadCountResponse:
      type: object
      properties:
        type:
          type: string
          example: unread_count
        count:
          type: integer
